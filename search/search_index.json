{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"optics-ts","text":"<p><code>optics-ts</code> provides type-safe, ergonomic, polymorphic optics for TypeScript</p> <ul> <li>Many optic types: lens, prism, traversal, getter, affine fold, fold, setter</li> <li>Optics for operating on multiple data types: objects, arrays, discriminated   unions, strings.</li> <li>Removable optics: Allow removing items from containers.</li> <li>Ergonomic API: No boilerplate, concise naming.</li> <li>Type-safe: The compiler will type check all operations you do. No <code>any</code>, ever.</li> <li>Most optics are fully polymorphic: You can write a different data type and   still get full type safety.</li> <li>Supports both ES6 and CommonJS modules in a single code base.</li> <li>Tree shaking support with standalone optics (see   The Two Syntaxes).</li> </ul>"},{"location":"#example","title":"Example","text":"Method chaining <pre><code>import * as O from 'optics-ts'\n\ntype Book = {\ntitle: string\nisbn: string\nauthor: {\nname: string\n}\n}\n\n// Create a lens that focuses on author.name\nconst optic = O.optic_&lt;Book&gt;()\n.prop('author')\n.prop('name')\n\n// This is the input data\nconst input: Book = {\ntitle: \"The Hitchhiker's Guide to the Galaxy\"\nisbn: \"978-0345391803\",\nauthor: {\nname: \"Douglas Adams\"\n}\n}\n\n// Read through the optic\nO.get(optic)(input)\n// \"Douglas Adams\"\n\n// Write through the optic\nO.set(optic)(\"Arthur Dent\")(input)\n// {\n//   title: \"The Hitchhiker\u2019s Guide to the Galaxy\"\n//   isbn: \"978-0345391803\",\n//   author: {\n//     name: \"Arthur Dent\"\n//   }\n// }\n\n// Update the existing value through the optic, while also changing the data type\nO.modify(optic)(str =&gt; str.length + 29)(input)\n// {\n//   title: \"The Hitchhiker\u2019s Guide to the Galaxy\"\n//   isbn: \"978-0345391803\",\n//   author: {\n//     name: 42\n//   }\n// }\n</code></pre> Standalone <pre><code>import * as O from 'optics-ts/standalone'\n\n// Create a lens that focuses on author.name\nconst optic = O.compose('author', 'name')\n\n// This is the input data\nconst input = {\ntitle: \"The Hitchhiker's Guide to the Galaxy\"\nisbn: \"978-0345391803\",\nauthor: {\nname: \"Douglas Adams\"\n}\n}\n\n// Read through the optic\nO.get(optic, input)\n// \"Douglas Adams\"\n\n// Write through the optic\nO.set(optic, \"Arthur Dent\", input)\n// {\n//   title: \"The Hitchhiker\u2019s Guide to the Galaxy\"\n//   isbn: \"978-0345391803\",\n//   author: {\n//     name: \"Arthur Dent\"\n//   }\n// }\n\n// Update the existing value through the optic, while also changing the data type\nO.modify(optic, (str) =&gt; str.length + 29, input)\n// {\n//   title: \"The Hitchhiker\u2019s Guide to the Galaxy\"\n//   isbn: \"978-0345391803\",\n//   author: {\n//     name: 42\n//   }\n// }\n</code></pre> <p>For more information about the differences between the method chaining and standalone syntaxes, see The Two Syntaxes.</p>"},{"location":"installation/","title":"Installation","text":"<p>With npm:</p> <pre><code>npm install --save optics-ts\n</code></pre> <p>With yarn:</p> <pre><code>yarn add optics-ts\n</code></pre>"},{"location":"installation/#requirements","title":"Requirements","text":"<p>TypeScript &gt;= 4.1 and the <code>strictNullChecks</code> compiler option are required.</p> <p>I strongly recommend enabling all strict options in your project's <code>tsconfig.json</code>:</p> <pre><code>{\n\"compilerOptions\": {\n\"strict\": true\n}\n}\n</code></pre> <p>If this is not possible for your project, enable only the <code>strictNullChecks</code> option:</p> <pre><code>{\n\"compilerOptions\": {\n\"strictNullChecks\": true\n}\n}\n</code></pre>"},{"location":"prior-art/","title":"Prior art","text":"<p>There are many existing optics libraries of varying degree for JavaScript, but only few for TypeScript. It's generally hard to create good typings for optics in TypeScript, and the task becomes impossible if one tried to retrofit types on an existing JavaScript implementation.</p> <ul> <li> <p>partial.lenses is arguably the   most comprehensive and elegant optics library for JavaScript, and the source   of inspiration for optics-ts.</p> </li> <li> <p>monocle-ts is probably the most   popular TypeScript optics library.</p> </li> <li> <p>@grammarly/focal is not an optics   library per se, rather an UI framework for TypeScript.</p> </li> </ul> <p>The naming of optic classes was inspired by Glassery by Oleg Grenrus.</p>"},{"location":"reference-interop/","title":"Interoperability","text":"<p>Experimental</p> <p>This module is experimental and may receive backwards incompatible changes without a corresponding semver bump.</p> <p>Since optics-ts v2.2.0, there are two syntaxes for optics: method chaining and standalone optics. The interoperability API, documented here,\u00a0defines a bridge between the two syntaxes, giving e.g. library authors the freedom to allow their users to use either syntax.</p> <p>Everything below assumes the following import:</p> <pre><code>import * as I from 'optics-ts/interop\n</code></pre> <p>This module defines the following functions:</p> <ul> <li><code>I.get :: (optic, value) =&gt; value</code></li> <li><code>I.preview :: (optic, value) =&gt; value | undefined</code></li> <li><code>I.collect :: (optic, value) =&gt; value[]</code></li> <li><code>I.modify :: (optic, fn, value) =&gt; value</code></li> <li><code>I.set :: (optic, fn, value) =&gt; value</code></li> </ul> <p>The <code>optic</code> parameter for these function can be any of:</p> <ul> <li>A method chaining optic</li> <li>A standalone optic</li> </ul> <p>Otherwise the functions work exactly like the corresponding operations in either API.</p>"},{"location":"reference-intro/","title":"Introduction","text":""},{"location":"reference-intro/#what-are-optics","title":"What are optics?","text":"<p>Optics are a way to describe a \"path\" into a data structure, i.e. to concentrate on a part of the data structure. This is called the optic's focus. However, optics are not tied to any specific value of a data structure, but are standalone values themselves.</p> <p>Optics are composable in the sense that you can combine two optics together to construct another optic that combines the semantics of the two. This makes it possible to construct complex optics from basic optics, making them usable for a wide range of different data structures.</p> <p>Ultimately, an optic can be used to read the value in its focus from a given a data structure compatible with the optic. It can also be used to modify the value in its focus in an immutable way, i.e. leaving the original data structure intact.</p>"},{"location":"reference-intro/#types-of-optics","title":"Types of optics","text":"<p>The optic types supported by optics-ts are are Equivalence, Iso (isomorphism), Lens, Prism, Traversal, Getter, AffineFold, Fold and Setter. In addition, there's RemovablePrism, which is a special case of Prism.</p> <p>The types differ mainly on the possible number of focuses they have, and whether they are read-write, read-only or write-only. The following table summarizes these properties:</p> Type Focuses Read/Write Equivalence 1 R/W Iso 1 R/W Lens 1 R/W Prism 0..1 R/W RemovablePrism 0..1 R/W Traversal 0..n R/W Getter 1 R AffineFold 0..1 R Fold 0..n R Setter 1 W"},{"location":"reference-intro/#rules-of-composition","title":"Rules of composition","text":"<p>Any read-write and read-only optic can be composed with another read-write and read-only optic. The type of the resulting optic can be determined from this diagram:</p> <pre><code>Equivalence -&gt; Iso -&gt; Lens ---&gt; Prism ------&gt; Traversal\n                      |         |             |\n                      v         v             v\n                      Getter -&gt; AffineFold -&gt; Fold\n</code></pre> <p>When you compose two optics A and B, the result is the nearest optic that you get by following the arrows starting from both A and B.</p> <p>For example, composing a Getter with a Traversal yields a Fold. Composing an Iso with a Prism yields a Prism.</p> <p>Setter is special. You can only compose writable optics with setters. Setters cannot be further composed with any other optic.</p> <p>RemovablePrism behaves like a regular prism, but it can be used to remove the focus from its parent container. When composed with other optics, composes like (and turns back into) a regular Prism.</p>"},{"location":"reference-mc/","title":"Method chaining API","text":"<p>Note</p> <p>Since optics-ts v2.2.0, there are two syntaxes for optics: method chaining and standalone optics. For more information about the differences between them, see The Two Syntaxes.</p> <p>Everything below assumes the following import:</p> <pre><code>import * as O from 'optics-ts'\n</code></pre> <p>Optics are composed with method chaining. This means that each optic type has most of the methods documented below, regardless of the type of the optic that the method creates. The only difference is the return type, which is determined by the composition rules above.</p> <p>For example, assume we have a variable <code>myLens</code> that holds a <code>Lens</code>, and call <code>.optional()</code> on it:</p> <pre><code>const newOptic = myLens.optional()\n</code></pre> <p><code>.optional()</code> creates a prism, so <code>newOptic</code> will be a composition of lens and prism, i.e. a prism.</p> <p>Which methods each optic type has depends on the composition rules presented in Rules of composition. For example, the <code>.prop()</code> method creates a lens, so a getter has that method because you can compose a getter and a lens. On the other hand, the <code>.appendTo()</code> method, which creates a setter, is not available in a getter, because getters cannot be composed with setters.</p>"},{"location":"reference-mc/#type-parameters","title":"Type parameters","text":"<p>All writable optics have 3 type parameters: <code>&lt;S, T, A&gt;</code>, and all read-only optics have 2 type parameters: <code>&lt;S, A&gt;</code>:</p> <ul> <li> <p><code>S</code> is the source on which the optic operates</p> </li> <li> <p><code>A</code> is the type of the focus or focuses</p> </li> <li> <p><code>T</code> is a type that encodes how the output type is constructed with polymorphic   writes, as well as info about the optic's removability</p> </li> </ul> <p>Conceptually, when you write a value of type <code>B</code>, the output type will be <code>S</code> with <code>A</code> replaced by <code>B</code> at the focus(es) of the optic. <code>T</code> contains a mechanism that transforms <code>B</code> to the output type. This construct makes it possible for the optics to be polymorphic on the type level. The read-only optics don't need <code>T</code> because you cannot write through them or remove their focus.</p> <p>In the following, we leave the exact definition of <code>T</code> for each optic out for clarity, writing just <code>_</code> in its place. It's usually clear from how the optic works what will come out if you write a value of a different type.</p> <p>In the documentation of functions that can be used to write through an optic, the return type is denoted by <code>T&lt;B&gt;</code>. While not valid TypeScript syntax (because <code>T</code> is a type parameter instead of a concrete type), this captures the meaning quite well: <code>B</code> is applied to the \"higher-kinded\" type <code>T</code>, yielding the output type.</p> <p>Interested readers can refer to hkt.ts to see how the higher-kinded types / partially applied type operators are actually implemented.</p>"},{"location":"reference-mc/#top-level-functions","title":"Top-level functions","text":"<p>These functions are available as top level exports of the <code>optics-ts</code> module.</p> <p>Most functions have <code>Optic</code> in their signature. It means that multiple optics work with the function. The optic classes that are actually applicable are documented in the function description.</p>"},{"location":"reference-mc/#optic","title":"<code>optic</code>","text":"<p>Signature: <code>optic&lt;S&gt;(): Equivalence&lt;S, _, S&gt;</code></p> <p>Create a monomorphic equivalence for <code>S</code>. If you ever see the type <code>DisallowedTypeChange</code>, it means that you have attempted to change a type with a monomorphic optic.</p>"},{"location":"reference-mc/#optic_","title":"<code>optic_</code>","text":"<p>Signature: <code>optic_&lt;S&gt;(): Equivalence&lt;S, _, S&gt;</code></p> <p>Create a polymorphic equivalence for <code>S</code>.</p>"},{"location":"reference-mc/#get","title":"<code>get</code>","text":"<p>Signature: <code>get&lt;S, A&gt;(optic: Optic&lt;S, _, A&gt;) =&gt; (source: S) =&gt; A</code></p> <p>Read a value through an <code>Equivalence</code>, <code>Iso</code>, <code>Lens</code> or <code>Getter</code>.</p>"},{"location":"reference-mc/#preview","title":"<code>preview</code>","text":"<p>Signature: <code>preview&lt;S, A&gt;(optic: Optic&lt;S, _, A&gt;) =&gt; (source: S) =&gt; A | undefined</code></p> <p>Read a value through a <code>Prism</code>, <code>Traversal</code>, <code>AffineFold</code> or <code>Fold</code>. For <code>Prism</code> and <code>AffineFold</code>, return <code>undefined</code> if the optic doesn't match (has zero focuses). For <code>Traversal</code> and <code>Fold</code>, returns the value of the first focus, or <code>undefined</code> if there are no focuses.</p>"},{"location":"reference-mc/#collect","title":"<code>collect</code>","text":"<p>Signature: <code>collect&lt;S, A&gt;(optic: Optic&lt;S, _, A&gt;) =&gt; (source: S) =&gt; A[]</code></p> <p>Read all focused values through a <code>Prism</code>, <code>Traversal</code>, <code>AffineFold</code> or <code>Fold</code>. For <code>Prism</code> and <code>AffineFold</code>, the return value is an array of 0 or 1 elements. For <code>Traversal</code> and <code>Fold</code>, the return value is an array of zero or more elements.</p>"},{"location":"reference-mc/#modify","title":"<code>modify</code>","text":"<p>Signature: <code>modify&lt;S, T, A&gt;(optic: Optic&lt;S, T, A&gt;) =&gt; &lt;B&gt;(f: (a: A) =&gt; B) =&gt; (source: S) =&gt; T&lt;B&gt;</code></p> <p>Modify the focused value(s) through an <code>Equivalence</code>, <code>Iso</code>, <code>Lens</code>, <code>Prism</code> or <code>Traversal</code>. Returns an updated copy of <code>source</code> with all focuses modified by mapping them through the function <code>f</code>.</p>"},{"location":"reference-mc/#set","title":"<code>set</code>","text":"<p>Signature: <code>set&lt;S, T, A&gt;(optic: Optic&lt;S, T, A&gt;) =&gt; &lt;B&gt;(value: B) =&gt; (source: S) =&gt; T&lt;B&gt;</code></p> <p>Write a constant value through an <code>Equivalence</code>, <code>Iso</code>, <code>Lens</code>, <code>Prism</code> or <code>Traversal</code>. Returns an updated copy of <code>source</code> with all focuses replaced by <code>value</code>.</p>"},{"location":"reference-mc/#remove","title":"<code>remove</code>","text":"<p>Signature: <code>remove&lt;S, T, A&gt;(optic: Optic&lt;S, T, A&gt;) =&gt; (source: S) =&gt; S</code></p> <p>Remove the focus of a <code>RemovablePrism</code> from its containing container.</p>"},{"location":"reference-mc/#compose","title":"<code>compose</code>","text":"<p>Signature: <code>compose&lt;S, A1, A2&gt;&lt;optic1: Optic&lt;S, _, A1&gt;, optic2: Optic&lt;A1, _, A2&gt;): Optic&lt;S, _, A2&gt;</code></p> <p>Compose two optics. If the first optic is from <code>S</code> to <code>A1</code>, and the second optic is from <code>A1</code> to <code>A2</code>, the result is from <code>S</code> to <code>A2</code>.</p> <p>See Rules of composition for the rules of composition.</p>"},{"location":"reference-mc/#pipe","title":"<code>pipe</code>","text":"<p>Signature: <code>pipe&lt;A, B, C, ..., V&gt;(a: A, ab: (a: A) =&gt; B, bc: (b: B) =&gt; C, ...): V</code></p> <p>Pipe the value of an expression (<code>a</code>) into a pipeline of at most 9 unary functions (<code>ab</code>, <code>bc</code>, ...).</p>"},{"location":"reference-mc/#creating-optics","title":"Creating optics","text":"<p>The methods documented below are available on all optics types: <code>Equivalence</code>, <code>Iso</code>, <code>Lens</code>, <code>Prism</code>, <code>Traversal</code>, <code>Getter</code>, <code>AffineFold</code> and <code>Fold</code>. The documented return type is the type of the optic that these methods create. The actual return type is the composition of the optic on which the method is called and on the optic that the method creates.</p> <p>Note that there are no functions to create <code>AffineFold</code> or <code>Fold</code> optics. You can only get these by composing other types of optics. <code>Equivalence</code> can be created by calling the top-level <code>optic</code> or <code>optic_</code> functions.</p>"},{"location":"reference-mc/#isomorphisms","title":"Isomorphisms","text":"<p>Isomorphisms have the type <code>Iso&lt;S, T, A&gt;</code>. In the following, we omit the exact definition of <code>T</code> for clarity, and use <code>_</code> instead. See Type parameters for the meanings of type parameters.</p>"},{"location":"reference-mc/#iso","title":"<code>iso</code>","text":"<p>Signature: <code>iso&lt;U&gt;(there: (a: A) =&gt; U, back: (u: U) =&gt; A): Iso&lt;S, _, U&gt;</code></p> <p>Create an isomorphism from functions <code>there</code> and <code>back</code>. <code>there</code> takes the focus and transforms it to another value. <code>back</code> is the inverse of <code>there</code>.</p> <p>Note that <code>iso</code> is monomorphic. There's no polymorphic alternative (yet).</p>"},{"location":"reference-mc/#indexed","title":"<code>indexed</code>","text":"<p>Signature: <code>indexed(): Iso&lt;S, _, [number, ElemType&lt;A&gt;][]&gt;</code></p> <p>Only works on arrays. <code>ElemType&lt;A&gt;</code> is the element type of the array type <code>A</code>.</p> <p>Ceate an isomorphism from an array of values to an array of index-value pairs, i.e. from <code>[a, b, ...]</code> to <code>[[0, a], [1, b], ...]</code>.</p> <p>In the write direction, elements are sorted by index, and only the last one of duplicate indices are kept.</p>"},{"location":"reference-mc/#lenses","title":"Lenses","text":"<p>Lenses have the type <code>Lens&lt;S, T, A&gt;</code>. In the following, we omit the exact definition of <code>T</code> for clarity, and use <code>_</code> instead. See Type parameters for the meanings of type parameters.</p>"},{"location":"reference-mc/#prop","title":"<code>prop</code>","text":"<p>Signature: <code>prop&lt;K extends keyof A&gt;(key: K): Lens&lt;S, _, A[K]&gt;</code></p> <p>Create a lens that focuses on the property <code>K</code> of <code>A</code>.</p> <p>Note: <code>prop()</code> only works for string properties, even though TypeScript's type system also allows array's numeric indices when using <code>keyof</code>. Use the <code>at</code> prism to focus on an array element at a given index.</p>"},{"location":"reference-mc/#path","title":"<code>path</code>","text":"<p>Signature: <code>path&lt;K1, K2, ...&gt;(...keys: [K1, K2, ...]): Lens&lt;S, _, A[K1][K2]...&gt;</code></p> <p>A shortcut for focusing on chain of properties.</p> <pre><code>foo.path('a.b.c')\n</code></pre> <p>is equal to</p> <pre><code>foo.path('a', 'b', 'c')\n</code></pre> <p>which is equal to</p> <pre><code>foo.prop('a').prop('b').prop('c')\n</code></pre>"},{"location":"reference-mc/#nth","title":"<code>nth</code>","text":"<p>Signature: <code>nth&lt;N extends number&gt;(n: N): Lens&lt;S, _, Nth&lt;A, N&gt;&gt;</code></p> <p>Only works on tuples whose length is a least <code>N + 1</code>.</p> <p>Create a lens that focuses on the index <code>N</code> of <code>A</code>. This is a lens because the length of <code>A</code> is checked on type level, so index <code>N</code> is always defined.</p> <p>See <code>at</code> below for a similar prism that works on arrays of arbitrary length.</p>"},{"location":"reference-mc/#pick","title":"<code>pick</code>","text":"<p>Signature: <code>pick&lt;K extends keyof A&gt;(keys: K[]): Lens&lt;S, _, Pick&lt;A, K&gt;&gt;</code></p> <p>Create a lens that focuses on a sub-object of <code>A</code> with the given properties. When writing through a polymorphic <code>.pick()</code> lens, you can add or remove properties.</p> <p>Example:</p> <pre><code>const data = {\nfoo: 'something',\nbar: 42,\nbaz: true,\n}\nconst lens = O.optic_&lt;typeof data&gt;().pick(['foo', 'bar'])\n\nO.get(lens)(data)\n// {\n//  foo: 'something',\n//  baz: true,\n// }\n\nO.set(lens)({ quux: null })(data)\n// {\n//   quux: null,\n//   baz: true,\n// }\n\n// monomorphic version of the same lens\nconst monoLens = O.optic&lt;typeof data&gt;().compose(lens)\n\nO.set(monoLens)({ quux: null })(data)\n// DisallowedTypeChange\n</code></pre>"},{"location":"reference-mc/#filter","title":"<code>filter</code>","text":"<p>Signatures:</p> <ul> <li><code>filter(pred: (item: ElemType&lt;A&gt;) =&gt; boolean): Lens&lt;S, _, A&gt;</code></li> <li><code>filter&lt;B&gt;(pred: (item: ElemType&lt;A&gt;) =&gt; item is B): Lens&lt;S, _, B[]&gt;</code></li> </ul> <p>Only works on arrays. <code>ElemType&lt;A&gt;</code> is the element type of the array type <code>A</code>.</p> <p>Create a lens that focuses on the elements matched by <code>pred</code>. If <code>pred</code> is a type guard of <code>B</code>, narrow the type of the focus to <code>B[]</code>.</p> <pre><code>const l = O.optic_&lt;number[]&gt;().filter((x) =&gt; x % 2 === 1)\n\n// Writing an array of the same length replaces elements\nO.set(l)(['a', 'b', 'c'])([1, 2, 3, 5, 6])\n// ['a', 2, 'b', 'c', 6]\n\n// Writing a shorter array removes elements\nO.set(l)(['a', 'b'])([1, 2, 3, 5, 6])\n// ['a', 2, 'b', 6]\n\n// Writing a longer array adds elements to the end\nO.set(l)(['a', 'b', 'c', 'd', 'e'])([1, 2, 3, 5, 6])\n// ['a', 2, 'b', 'c', 6, 'd', 'e']\n</code></pre> <p>When a different type <code>U extends any[]</code> is written, the result will have the type <code>A | U</code>, i.e. <code>(ElemType&lt;A&gt; | ElemType&lt;U&gt;)[]</code>.</p>"},{"location":"reference-mc/#valueor","title":"<code>valueOr</code>","text":"<p>Signature: <code>valueOr&lt;B&gt;(defaultValue: B): Lens&lt;S, _, Exclude&lt;A, undefined&gt; | B&gt;</code></p> <p>Create a lens that, when read through, returns <code>defaultValue</code> when the focused value is <code>undefined</code>. If the focus is not <code>undefined</code>, the focus is returned unchanged.</p> <p>Fully polymorphic in the write direction.</p>"},{"location":"reference-mc/#partsof","title":"<code>partsOf</code>","text":"<p>Signatures:</p> <ul> <li><code>partsOf(traversal: Traversal&lt;A, _, B&gt;): Lens&lt;S, _, B[]&gt;</code></li> <li><code>partsOf(makeTraversal: (o: Optic&lt;A&gt;) =&gt; Traversal&lt;A, _, B&gt;): Lens&lt;S, _, B[]&gt;</code></li> </ul> <p>Create a lens from the given traversal, or from the traversal returned by the given function. When read through, the result is an array of elements as if produced by <code>collect</code>. When written through, the focuses of the traversal are replaced with the values from the written array. For a polymorphic write, the focuses of the tarversal get the type of the written array elements. If a shorter or longer array is written, throws an error. This is to ensure that all focuses are replaced and the types are correct.</p> <p>For example, this reverses the words of a string:</p> <pre><code>const lens = O.optic&lt;string&gt;().partsOf((o) =&gt; o.words())\nO.modify(lens)((words) =&gt; [...words].reverse())('this is a test')\n// 'test a is this'\n</code></pre> <p>Note that composing <code>partsOf</code> with setters (like <code>appendTo</code> or <code>prependTo</code>) or removing elements through <code>partsOf</code> will not work, because the extra element added by the setter or the removed element will cause <code>partsOf</code> to throw.</p>"},{"location":"reference-mc/#reread","title":"<code>reread</code>","text":""},{"location":"reference-mc/#rewrite","title":"<code>rewrite</code>","text":"<p>Signatures:</p> <ul> <li><code>reread(fn: (value: A) =&gt; A): Lens&lt;S, _, A&gt;</code></li> <li><code>rewrite(fn: (value: A) =&gt; A): Lens&lt;S, _, A&gt;</code></li> </ul> <p>Create a lens that can modify the value in the read direction (<code>reread()</code>) or write direction (<code>rewrite()</code>). This is useful to e.g. ensure data structure invariants in some cases.</p> <p>Note that both <code>reread</code> and <code>rewrite</code> are monomorphic.</p>"},{"location":"reference-mc/#lens","title":"<code>lens</code>","text":"<p>Signature: <code>lens&lt;U&gt;(view: (a: A) =&gt; U, update: (a: A, u: U) =&gt; A): Lens&lt;S, _, U&gt;</code></p> <p>Create a lens from functions <code>view</code> and <code>update</code>. <code>view</code> takes the current focus and returns a new focus. <code>update</code> takes the orginal focus and a value, and updates the original focus with that value.</p> <p>Note that <code>lens</code> is monomorphic. There's no polymorphic alternative (yet).</p>"},{"location":"reference-mc/#prisms","title":"Prisms","text":"<p>Prisms have the type <code>Prism&lt;S, T, A&gt;</code>. In the following, we omit the exact definition of <code>T</code> for clarity, and use <code>_</code> instead. See Type parameters for the meanings of type parameters.</p>"},{"location":"reference-mc/#optional","title":"<code>optional</code>","text":"<p>Signature: <code>optional(): Prism&lt;S, _, Exclude&lt;A, undefined&gt;&gt;</code></p> <p>Create a prism that focuses on the non-<code>undefined</code> subtype of <code>A</code>.</p>"},{"location":"reference-mc/#guard","title":"<code>guard</code>","text":"<p>Signature: <code>guard&lt;U extends A&gt;(g: (a: A) =&gt; a is U): Prism&lt;S, _, U&gt;</code></p> <p>Create a prism that focuses on the subtype <code>U</code> of <code>A</code> that matches the type guard <code>g</code>.</p> <p>Note that <code>guard()</code> is monomorphic. Use <code>guard_</code> if you want a polymorphic guard.</p>"},{"location":"reference-mc/#guard_","title":"<code>guard_</code>","text":"<p>Signature: <code>guard_&lt;F extends HKT&gt;(): &lt;U extends A&gt;(g: (a: A) =&gt; a is U) =&gt; Prism&lt;S, T \u00b7 F, U&gt;</code></p> <p>Create a prism that focuses on the subtype of <code>A</code> that matches the type guard <code>g</code>. When written to, uses the higher-kinded type <code>F</code> to construct the output type.</p>"},{"location":"reference-mc/#at","title":"<code>at</code>","text":"<p>Signature: <code>at(i: number): RemovablePrism&lt;S, _, ElemType&lt;A&gt;&gt;</code></p> <p>Only works on arrays and strings. Removable. <code>ElemType&lt;A&gt;</code> is the element type of the array type <code>A</code>.</p> <p>Create a prism that focuses on the element type of the array <code>A</code>, or on a substring of length 1 if <code>A</code> is <code>string</code>.</p> <p>When an element of a different type <code>B</code> is written to an array, the resulting array will have the type <code>Array&lt;A | B&gt;</code>.</p> <p>When writing to a string, only strings can be written. The length of the written string can be something else than 1.</p>"},{"location":"reference-mc/#head","title":"<code>head</code>","text":"<p>Signature: <code>head(): Prism&lt;S, _, ElemType&lt;A&gt;&gt;</code></p> <p>Short for <code>at(0)</code>.</p>"},{"location":"reference-mc/#index","title":"<code>index</code>","text":"<p>Signature: <code>index(i: number): RemovablePrism&lt;S, _, ElemType&lt;A&gt;&gt;</code></p> <p>Deprecated. Alias for <code>at</code>.</p>"},{"location":"reference-mc/#find","title":"<code>find</code>","text":"<p>Signature: <code>find(p: (e: ElemType&lt;A&gt;) =&gt; boolean): RemovablePrism&lt;S, _, ElemType&lt;A&gt;&gt;</code></p> <p>Only works on array types. Removable. <code>ElemType&lt;A&gt;</code> is the element type of the array type <code>A</code>.</p> <p>Like <code>at</code>, but the index to be focused on is determined by finding the first element that matches the given predicate.</p> <p>When a different type <code>B</code> is written through this optic, the resulting array will have the type <code>Array&lt;A | B&gt;</code>.</p>"},{"location":"reference-mc/#when","title":"<code>when</code>","text":"<p>Signature: <code>when(f: (a: A) =&gt; boolean): Prism&lt;S, _, A&gt;</code></p> <p>Create a prism that skips the focus if it doesn't match the given predicate. Especially useful for filtering the focuses of a travesal.</p> <p>When a different type <code>B</code> is written through this optic, the resulting value will have the type <code>A | B</code>.</p>"},{"location":"reference-mc/#traversals","title":"Traversals","text":"<p>Traversals have the type <code>Traversal&lt;S, T, A&gt;</code>. In the following, we omit the exact definition of <code>T</code> for clarity, and use <code>_</code> instead. See Type parameters for the meanings of type parameters.</p>"},{"location":"reference-mc/#elems","title":"<code>elems</code>","text":"<p>Signature: <code>elems(): Traversal&lt;S, _, ElemType&lt;A&gt;&gt;</code></p> <p>Only works on array types. <code>ElemType&lt;A&gt;</code> is the element type of the array type <code>A</code>.</p> <p>Create a traversal that focuses on all the elements of the array.</p>"},{"location":"reference-mc/#getters","title":"Getters","text":"<p>Getters are read-only optics with a single focus. You can think of them like one-way isomorphisms or read-only lenses.</p> <p>Getters have the type <code>Getter&lt;S, A&gt;</code>. See Type parameters for the meanings of type parameters.</p>"},{"location":"reference-mc/#to","title":"<code>to</code>","text":"<p>Signature: <code>to&lt;B&gt;(f: (a: A) =&gt; B): Getter&lt;S, B&gt;</code></p> <p>Create a getter that applies the function <code>f</code> to its focus.</p>"},{"location":"reference-mc/#setters","title":"Setters","text":"<p>Setters have the type <code>Setter&lt;S, T, A&gt;</code>. In the following, we omit the exact definition of <code>T</code> for clarity, and use <code>_</code> instead. See Type parameters for the meanings of type parameters.</p>"},{"location":"reference-mc/#prependto","title":"<code>prependTo</code>","text":""},{"location":"reference-mc/#appendto","title":"<code>appendTo</code>","text":"<p>Signatures:</p> <ul> <li><code>prependTo(): Setter&lt;S, _, ElemType&lt;A&gt;&gt;</code></li> <li><code>appendTo(): Setter&lt;S, _, ElemType&lt;A&gt;&gt;</code></li> </ul> <p>Only works on arrays. <code>ElemType&lt;A&gt;</code> is the element type of the array type <code>A</code>.</p> <p>Create a setter that focuses on the part before the first element or after the last element of the focus array. When written through, prepends or appends the value to the array.</p> <p>When an element of a different type <code>B</code> is written, the resulting array will have the type <code>Array&lt;A | B&gt;</code>.</p>"},{"location":"reference-mc/#composing","title":"Composing","text":""},{"location":"reference-mc/#compose_1","title":"<code>compose</code>","text":"<p>Signature: <code>compose&lt;B&gt;(other: Optic&lt;A, _, B&gt;): Optic&lt;S, _, B&gt;</code></p>"},{"location":"reference-mc/#strings","title":"Strings","text":"<p>The following optics only work on strings.</p>"},{"location":"reference-mc/#chars","title":"<code>chars</code>","text":"<p>Signature: <code>chars(): Traversal&lt;S, _, string&gt;</code></p> <p>Create a traversal that focuses on all the characters of the current string focus.</p> <p>When written through, characters can be removed by writing the empty string, or changed to longer strings.</p>"},{"location":"reference-mc/#words","title":"<code>words</code>","text":"<p>Signature: <code>words(): Traversal&lt;S, _, string&gt;</code></p> <p>Create a traversal that focuses on all the words of the current string focus. Words are substrings that are separated by whitespace.</p> <p>When written through, words can be removed by writing the empty string, or changed to longer or shorter strings.</p>"},{"location":"reference-standalone/","title":"Standalone API","text":"<p>Note</p> <p>Since optics-ts v2.2.0, there are two syntaxes for optics: method chaining and standalone optics. For more information about the differences between them, see The Two Syntaxes.</p> <p>Experimental</p> <p>This module is experimental and may receive backwards incompatible changes without a corresponding semver bump.</p> <p>Everything below assumes the following import:</p> <pre><code>import * as O from 'optics-ts/standalone'\n</code></pre>"},{"location":"reference-standalone/#typescript-types","title":"TypeScript types","text":"<p>In general, the TypeScript types of optics look like <code>Optic&lt;C, A, T, R&gt;</code>.</p> <ul> <li> <p><code>C</code> is the optic type as a string, e.g. <code>'Lens'</code> or <code>'Prism'</code></p> </li> <li> <p><code>A</code> and <code>T</code> encode the optic's read and write direction transforms as   \"higher-kinded\" types</p> </li> <li> <p><code>R</code> is <code>true</code> if the optic is removable, and <code>undefined</code> otherwise.</p> </li> </ul> <p>In the following, we leave the exact type signatures out for clarity, using a hand-wavy pseudo syntax instead. The optic descriptions try to make it clear how optics and functions operate.</p> <p>Interested readers can refer to hkt.ts to see how the higher-kinded types / partially applied type operators are actually implemented.</p>"},{"location":"reference-standalone/#operations","title":"Operations","text":"<p>These function are not optics themselves, but instead operate on the optics and data.</p>"},{"location":"reference-standalone/#compose","title":"<code>compose</code>","text":"<p><code>compose :: (optic, ...optics) =&gt; Optic</code></p> <p>Compose optics to create a more complex optic. Using a string as an optic is a shorthand for prop.</p> <p>Example:</p> <pre><code>const fooBar = O.compose('foo', O.optional, 'bar')\n\nO.preview(fooBar, { foo: undefined })\n// undefined\n\nO.preview(fooBar, { foo: { bar: 5 } })\n// 5\n</code></pre>"},{"location":"reference-standalone/#get","title":"<code>get</code>","text":"<p><code>get :: (optic, source) =&gt; value</code> <code>get :: (optic) =&gt; (source) =&gt; value</code></p> <p>Read a value through an <code>Equivalence</code>, <code>Iso</code>, <code>Lens</code> or <code>Getter</code>.</p> <p>Example:</p> <pre><code>O.get(O.pick('foo', 'baz'), { foo: 1, bar: 2, baz: 3 })\n// { foo: 1, baz: 3 }\n</code></pre>"},{"location":"reference-standalone/#preview","title":"<code>preview</code>","text":"<p><code>preview :: (optic, source) =&gt; value | undefined</code> <code>preview :: (optic) =&gt; (source) =&gt; value | undefined</code></p> <p>Read a value through a <code>Prism</code>, <code>Traversal</code>, <code>AffineFold</code> or <code>Fold</code>. For <code>Prism</code> and <code>AffineFold</code>, return <code>undefined</code> if the optic doesn't match (has zero focuses). For <code>Traversal</code> and <code>Fold</code>, returns the value of the first focus, or <code>undefined</code> if there are no focuses.</p> <p>Example:</p> <pre><code>O.preview(O.optional, 1)\n// 1\n\nO.preview(O.elems, [])\n// undefined\n</code></pre>"},{"location":"reference-standalone/#collect","title":"<code>collect</code>","text":"<p><code>collect :: (optic, source) =&gt; value[]</code> <code>collect :: (optic) =&gt; (source) =&gt; value[]</code></p> <p>Read all focused values through a <code>Prism</code>, <code>Traversal</code>, <code>AffineFold</code> or <code>Fold</code>. For <code>Prism</code> and <code>AffineFold</code>, the return value is an array of 0 or 1 elements. For <code>Traversal</code> and <code>Fold</code>, the return value is an array of zero or more elements.</p> <p>Example:</p> <pre><code>O.collect(O.optional, 1)\n// [1]\n\nO.collect(O.elems, [])\n// []\n</code></pre>"},{"location":"reference-standalone/#modify","title":"<code>modify</code>","text":"<p><code>modify :: (optic, fn, source) =&gt; value</code> <code>modify :: (optic) =&gt; (fn, source) =&gt; value</code> <code>modify :: (optic) =&gt; (fn) =&gt; (source) =&gt; value</code></p> <p>Modify the focused value(s) through an <code>Equivalence</code>, <code>Iso</code>, <code>Lens</code>, <code>Prism</code> or <code>Traversal</code>. Returns an updated copy of <code>source</code> with all focuses modified by mapping them through the function <code>fn</code>.</p> <p>Example:</p> <pre><code>O.modify(O.prop('foo'), (value) =&gt; value.length, { foo: 'bar' })\n// { foo: 3 }\n</code></pre>"},{"location":"reference-standalone/#set","title":"<code>set</code>","text":"<p>Signatures:</p> <p><code>set :: (optic, newValue, source) =&gt; value</code> <code>set :: (optic) =&gt; (newValue, source) =&gt; value</code> <code>set :: (optic) =&gt; (newValue) =&gt; (source) =&gt; value</code></p> <p>Write a constant value through an <code>Equivalence</code>, <code>Iso</code>, <code>Lens</code>, <code>Prism</code> or <code>Traversal</code>. Returns an updated copy of <code>source</code> with all focuses replaced by <code>newValue</code>.</p> <p>Example:</p> <pre><code>O.set(O.prop('foo'), null, { foo: 'bar' })\n// { foo: null }\n</code></pre>"},{"location":"reference-standalone/#remove","title":"<code>remove</code>","text":"<p><code>remove :: (optic, source) =&gt; value</code> <code>remove :: (optic) =&gt; (source) =&gt; value</code></p> <p>Remove the focus of a <code>RemovablePrism</code> from its containing container.</p> <p>Example:</p> <pre><code>O.remove(O.at(1), [1, 2, 3])\n// [1, 3]\n</code></pre>"},{"location":"reference-standalone/#isomorphisms","title":"Isomorphisms","text":""},{"location":"reference-standalone/#iso","title":"<code>iso</code>","text":"<p><code>iso :: (there: (v) =&gt; u, back: (u) =&gt; v) =&gt; Iso</code></p> <p>Create an isomorphism from functions <code>there</code> and <code>back</code>. <code>there</code> takes the focus and transforms it to another value. <code>back</code> is the inverse of <code>there</code>.</p> <p>Note that <code>iso</code> is monomorphic, i.e. you cannot change the value type when writing. There's no polymorphic alternative (yet).</p> <p>Example:</p> <pre><code>const sep = O.iso(\n(value: string) =&gt; value.split(','),\n(arr: string[]) =&gt; arr.join(',')\n)\n\nO.get(sep, 'foo,bar,baz')\n// ['foo', 'bar', 'baz']\n\nO.modify(sep, (arr) =&gt; [...arr].reverse(), 'foo,bar,baz')\n// 'baz,bar,foo'\n</code></pre>"},{"location":"reference-standalone/#indexed","title":"<code>indexed</code>","text":"<p><code>indexed :: Iso</code></p> <p>Only works on arrays.</p> <p><code>indexed</code> is an isomorphism from an array of values to an array of index-value pairs, i.e. from <code>[a, b, ...]</code> to <code>[[0, a], [1, b], ...]</code>.</p> <p>In the write direction, elements are sorted by index, and only the last one of duplicate indices are kept.</p> <p>Example:</p> <pre><code>O.get(O.indexed, ['a', 'b', 'c'])\n// [[0, 'a'], [1, 'b'], [2, 'c']]\n\nO.set(O.compose(O.indexed, O.at(1), O.nth(0)), 3, ['a', 'b', 'c'])\n// ['a', 'c', 'b']\n</code></pre>"},{"location":"reference-standalone/#lenses","title":"Lenses","text":""},{"location":"reference-standalone/#prop","title":"<code>prop</code>","text":"<p><code>prop :: (key) =&gt; Lens</code></p> <p>Create a lens that focuses on the object property <code>key</code>.</p> <p>You can also just simply pass a string to <code>compose</code> instead of using <code>prop</code>.</p> <p>Example:</p> <pre><code>O.set(O.prop('foo'), 42, { foo: null })\n// { foo: 42 }\n</code></pre> <p>See <code>atKey</code> for a similar prism that works on records.</p>"},{"location":"reference-standalone/#nth","title":"<code>nth</code>","text":"<p><code>nth :: (n) =&gt; Lens</code></p> <p>Only works on tuples whose length is a least <code>n + 1</code>.</p> <p>Create a lens that focuses on the index <code>n</code> of a tuple. This is a lens because the length of the focus is checked on type level, so index <code>n</code> is always defined.</p> <p>See <code>at</code> for a similar prism that works on arrays.</p>"},{"location":"reference-standalone/#pick","title":"<code>pick</code>","text":"<p><code>pick :: (...keys) =&gt; Lens</code></p> <p>Create a lens that picks the given properties from an object. When writing through the lens, you can add or remove properties.</p> <p>Example:</p> <pre><code>const data = {\nfoo: 'something',\nbar: 42,\nbaz: true,\n}\n\nO.get(O.pick('foo', 'bar'), data)\n// {\n//  foo: 'something',\n//  baz: true,\n// }\n\nO.set(O.pick('foo'), {}, data)\n// {\n//   bar: 42,\n//   baz: true,\n// }\n\nO.set(O.pick(), { quux: 'added' }, data)\n// {\n//   foo: 'something'\n//   bar: 42,\n//   baz: true,\n//   quux: 'added',\n// }\n</code></pre>"},{"location":"reference-standalone/#filter","title":"<code>filter</code>","text":"<p><code>filter :: (fn: (elem) =&gt; boolean) =&gt; Lens</code></p> <p>Only works on arrays.</p> <p>Create a lens that focuses on the array elements matched by <code>fn</code>. If <code>fn</code> is a type guard of type <code>T</code>, narrow the type of the focus to <code>T[]</code>.</p> <p>Writing a longer/shorter array adds/removes elements. Extraneous elements are added to the end of the array.</p> <p>Example:</p> <pre><code>const l = O.filter((x: number) =&gt; x % 2 === 1)\n\nO.set(l, ['a', 'b', 'c'], [1, 2, 3, 5, 6])\n// ['a', 2, 'b', 'c', 6]\n\nO.set(l, ['a', 'b'], [1, 2, 3, 5, 6])\n// ['a', 2, 'b', 6]\n\nO.set(l, ['a', 'b', 'c', 'd', 'e'], [1, 2, 3, 5, 6])\n// ['a', 2, 'b', 'c', 6, 'd', 'e']\n</code></pre>"},{"location":"reference-standalone/#valueor","title":"<code>valueOr</code>","text":"<p><code>valueOr :: (defaultValue) =&gt; Lens</code></p> <p>Create a lens that, when read through, returns <code>defaultValue</code> when the focused value is <code>undefined</code>. If the focus is not <code>undefined</code>, the focus is returned unchanged.</p> <p>Example:</p> <pre><code>O.get(O.valueOr(0), undefined)\n// 0\n\nO.get(O.valueOr(0), 42)\n// 42\n\nO.get(O.compose('maxAge', O.valueOr(100)), { maxAge: undefined })\n// 100\n</code></pre>"},{"location":"reference-standalone/#partsof","title":"<code>partsOf</code>","text":"<p><code>partsOf :: (traversal) =&gt; Lens</code></p> <p>Given a traversal, create a lens that focuses on an array of the focuses of the traversal. When read through, the result is an array of elements as if produced by <code>collect</code>. When written through, the focuses of the traversal are replaced with the values from the written array. For a polymorphic write, the focuses of the tarversal get the type of the written array elements. If a shorter or longer array is written, throws an error. This is to ensure that all focuses are replaced and the types are correct.</p> <p>Example:</p> <pre><code>O.set(\nO.partsOf(O.compose(O.elems, 'foo')),\n['x', 'y', 'z'],\n[{ foo: 'a' }, { foo: 'b' }, { foo: 'c' }]\n)\n// [{ foo: 'x' }, { foo: 'y' }, { foo: 'z' }]\n\nO.modify(O.partsOf(O.words), (words) =&gt; [...words].reverse(), 'this is a test')\n// 'test a is this'\n</code></pre> <p>Note that composing <code>partsOf</code> with setters, like <code>appendTo</code> or <code>prependTo</code>, or removing elements through <code>partsOf</code> will not work, because the extra element added by the setter or the removed element will cause <code>partsOf</code> to throw.</p>"},{"location":"reference-standalone/#reread-rewrite","title":"<code>reread</code>, <code>rewrite</code>","text":"<p><code>reread :: (fn: (value) =&gt; value) =&gt; Lens</code> <code>rewrite :: (fn: (value) =&gt; value) =&gt; Lens</code></p> <p>Create a lens that can modify the value in the read direction (<code>reread</code>) or write direction (<code>rewrite</code>). This is useful to e.g. ensure data structure invariants in some cases.</p> <p>Both <code>reread</code> and <code>rewrite</code> are monomorphic.</p> <p>Example:</p> <pre><code>const read = O.reread((x: string) =&gt; x.toUpperCase())\nconst write = O.rewrite((x: string) =&gt; x.toUpperCase())\n\nO.get(read, 'foo')\n// FOO\n\nO.get(write, 'foo')\n// foo\n\nO.set(read, null, 'foo')\n// foo\n\nO.set(write, null, 'foo')\n// FOO\n</code></pre>"},{"location":"reference-standalone/#lens","title":"<code>lens</code>","text":"<p><code>lens :: (view: (v) =&gt; u, update: (v, u) =&gt; v) =&gt; Lens</code></p> <p>Create a lens from functions <code>view</code> and <code>update</code>. <code>view</code> takes the current focus and returns a new focus. <code>update</code> takes the orginal focus and a value, and updates the original focus with that value.</p> <p>Note that <code>lens</code> is monomorphic, i.e. you cannot change the value type when writing. There's no polymorphic alternative (yet).</p> <p>Example:</p> <pre><code>const lens = O.lens&lt;number | string, number&gt;(\n(v) =&gt; (typeof v === 'string' ? 0 : v),\n(_, u) =&gt; u\n)\n\nO.get(lens, 100)\n// 100\n\nO.get(lens, 'foo')\n// 0\n</code></pre>"},{"location":"reference-standalone/#prisms","title":"Prisms","text":""},{"location":"reference-standalone/#optional","title":"<code>optional</code>","text":"<p><code>optional :: Prism</code></p> <p>A prism that matches if the value is not <code>undefined</code>. Narrows the type to remove <code>undefined</code>, e.g. <code>number | undefined</code> narrows to <code>number</code>.</p> <p>Example:</p> <pre><code>const prism = O.compose('foo', O.optional, 'bar')\n\nO.preview(prism, { foo: { bar: 42 } })\n// 42\n\nO.preview(prism, { foo: undefined })\n// undefined\n</code></pre>"},{"location":"reference-standalone/#guard","title":"<code>guard</code>","text":"<p><code>guard :: (fn: (value) =&gt; boolean) =&gt; Prism</code> (monomorphic) <code>guard :: &lt;F&gt;() =&gt; (fn: (value) =&gt; boolean) =&gt; Prism</code> (polymorphic)</p> <p>Create a prism that matches if the value matches the type guard <code>fn</code>.</p> <p>The first, simpler signature returns a monomorphic prism, which can only be used for writes that don't change the type of the focus.</p> <p>The second signature returns a polymorphic prism that uses the type transform <code>F</code> to construct the result type.</p> <p>Monomorphic example:</p> <pre><code>type Circle = { type: 'circle'; radius: number }\ntype Square = { type: 'square'; size: number }\ntype Shape = Circle | Square\n\nfunction isCircle(value: Shape): value is Circle {\nreturn value.type === 'circle'\n}\n\nconst circle = { type: 'circle', radius: 42 }\nconst square = { type: 'square', size: 10 }\n\nconst circleRadius = O.compose(O.guard(isCircle), 'radius')\n\nO.preview(circleRadius, square)\n// undefined\n\nO.preview(circleRadius, circle)\n// 42\n\nO.set(circleRadius, 99, square)\n// { type: 'square', size: 10 }\n\nO.set(circleRadius, 99, circle)\n// { type: 'circle', radius: 99 }\n</code></pre> <p>Polymorphic example:</p> <pre><code>type Some&lt;T&gt; = { type: 'some'; value: T }\ntype None = { type: 'none' }\ntype Option&lt;T&gt; = Some&lt;T&gt; | None\n\n// O.HKT is a \"type transform\" or a \"higher-kinded type\". this[1] is the input\n// type, and the output is taken from prop 0.\n//\n// The SomeF type transform just checks that the input type in this[1] has the\n// shape of a Some, and passes it through as-is. In other words, the writer\n// can change the type of the 'value' prop, but nothing else.\n//\ninterface SomeF extends O.HKT {\n0: this[1] extends Some&lt;any&gt; ? this[1] : never\n}\n\nfunction isSomeNumber(value: Option&lt;number&gt;): value is Some&lt;number&gt; {\nreturn value.type === 'some'\n}\n\nconst someValue = O.compose(O.guard&lt;SomeF&gt;()(isSomeNumber), 'value')\n\nconst some: Option&lt;number&gt; = { type: 'some', value: 42 }\nconst none: Option&lt;number&gt; = { type: 'none' }\n\nO.preview(someValue, none)\n// undefined\n\nO.preview(someValue, some)\n// 42\n\nconst result1: Option&lt;string&gt; = O.set(someValue, 'foo', none)\n// { type: 'none' }\n\nconst result2: Option&lt;string&gt; = O.set(someValue, 'foo', some)\n// { type: 'some', value: 'foo' }\n</code></pre>"},{"location":"reference-standalone/#at","title":"<code>at</code>","text":"<p><code>at :: (i) =&gt; RemovablePrism</code></p> <p>Only works on arrays and strings. Removable.</p> <p>Create a prism that focuses on the n'th element of an array or the n'th character (substring of length 1) of a string.</p> <p>When used on a string, only strings can be written. Writing strings of a different length is supported.</p> <p>Example:</p> <pre><code>O.preview(O.at(1), ['a', 'b', 'c'])\n// 'b'\n\nO.preview(O.at(1), ['a'])\n// undefined\n\nO.set(O.at(1), 123, ['a', 'b', 'c'])\n// ['a', 123, 'c']\n\nO.set(O.at(1), 123, ['a'])\n// ['a']\n\nO.remove(O.at(1), ['a', 'b', 'c'])\n// ['a', 'c']\n\nO.preview(O.at(1), 'abc')\n// 'b'\n\nO.preview(O.at(1), 'a')\n// undefined\n\nO.set(O.at(1), 'X', 'abc')\n// 'aXc'\n\nO.set(O.at(1), 'X', 'a')\n// 'a'\n\nO.set(O.at(1), 'XYZ', 'abc')\n// 'aXYZc'\n\nO.set(O.at(1), '', 'abc')\n// 'ac'\n\nO.remove(O.at(1), 'abc')\n// 'ac'\n</code></pre>"},{"location":"reference-standalone/#head","title":"<code>head</code>","text":"<p><code>head :: Prism</code></p> <p>A shorthand for <code>at(0)</code>.</p>"},{"location":"reference-standalone/#atkey","title":"<code>atKey</code>","text":"<p><code>atKey :: (key) =&gt; RemovablePrism</code></p> <p>Only works on records (<code>Record&lt;string, T&gt;</code>). Removable.</p> <p>Create a prism that focuses on the key of a record.</p> <p>Example:</p> <pre><code>O.preview(O.atKey('foo'), { foo: 'bar' })\n// 'bar'\n\nO.preview(O.atKey('foo'), { hello: 'world' })\n// undefined\n\nO.set(O.atKey('foo'), 123, { foo: 'bar', hello: 'world' })\n// { foo: 123, hello: 'world' }\n\nO.set(O.atKey('foo'), 123, { hello: 'world' })\n// { hello: 'world' }\n\nO.remove(O.atKey('foo'), { foo: 'bar', hello: 'world' })\n// { hello: 'world' }\n</code></pre>"},{"location":"reference-standalone/#find","title":"<code>find</code>","text":"<p><code>find :: (fn: (elem) =&gt; boolean) =&gt; RemovablePrism</code></p> <p>Only works on arrays. Removable.</p> <p>Create a prism that focuses on the first element of an array which matches the predicate <code>fn</code>.</p> <p>Example:</p> <pre><code>const negativeElem = O.find((x: number) =&gt; x &lt; 0)\n\nO.preview(negativeElem, [1, 0, -1, -2])\n// -1\n\nO.modify(negativeElem, (x) =&gt; -x, [1, 0, -1, -2])\n// [1, 0, 1, -2]\n\nO.preview(negativeElem, [0, 2, 1])\n// undefined\n</code></pre>"},{"location":"reference-standalone/#when","title":"<code>when</code>","text":"<p><code>when :: (fn: (value) =&gt; boolean) =&gt; Prism</code></p> <p>Create a prism that matches it the focus matches the predicate <code>fn</code>. Especially useful for filtering the focuses of a travesal.</p> <p>Example:</p> <pre><code>const longWords = O.compose(\nO.words,\nO.when((s: string) =&gt; s.length &gt;= 5)\n)\nconst text = 'Some shorter and some longer words'\n\nO.collect(longWords, text)\n// ['shorter', 'longer', 'words']\n\nO.modify(longWords, (s) =&gt; s.toUpperCase(), text)\n// \"Some SHORTER and some LONGER WORDS\"\n</code></pre>"},{"location":"reference-standalone/#traversals","title":"Traversals","text":""},{"location":"reference-standalone/#elems","title":"<code>elems</code>","text":"<p><code>elems :: Traversal</code></p> <p>Only works on arrays.</p> <p>A traversal that focuses on all elements of an array.</p> <pre><code>O.collect(O.compose(O.elems, 'foo', 'bar'), [\n{ foo: { bar: 1 } },\n{ foo: { bar: 2 } },\n])\n// [1, 2]\n</code></pre>"},{"location":"reference-standalone/#getters","title":"Getters","text":"<p>Getters are read-only optics with a single focus. You can think of them like one-way isomorphisms or read-only lenses.</p>"},{"location":"reference-standalone/#to","title":"<code>to</code>","text":"<p><code>to :: (fn: (v) =&gt; u) =&gt; Getter</code></p> <p>Create a getter that applies the function <code>fn</code> to its focus.</p>"},{"location":"reference-standalone/#setters","title":"Setters","text":""},{"location":"reference-standalone/#prependto-appendto","title":"<code>prependTo</code>, <code>appendTo</code>","text":"<p><code>prependTo :: Setter</code> <code>appendTo :: Setter</code></p> <p>Only work on arrays.</p> <p><code>prependTo</code> focuses on the part before the first element and <code>appendTo</code> focuses on the part after the last element of an array. When written through, prepends or appends the value to the array.</p> <pre><code>O.set(O.appendTo, 3, [0, 1, 2])\n// [0, 1, 2, 3]\n\nO.set(O.prependTo, 3, [0, 1, 2])\n// [3, 0, 1, 2]\n</code></pre>"},{"location":"reference-standalone/#string-traversals","title":"String traversals","text":""},{"location":"reference-standalone/#chars","title":"<code>chars</code>","text":"<p><code>chars :: Traversal</code></p> <p>Only works on strings.</p> <p>A traversal that focuses on all the characters of a string.</p> <p>When written through, characters can be removed by writing the empty string, or changed to longer strings.</p> <pre><code>O.collect(O.chars, 'foo')\n// ['f', 'o', 'o']\n\nO.modify(O.chars, (c) =&gt; (c == 'o' ? '' : c.toUpperCase()), 'foobar')\n// 'FBAR'\n</code></pre>"},{"location":"reference-standalone/#words","title":"<code>words</code>","text":"<p><code>words :: Traversal</code></p> <p>Only works on strings.</p> <p>A traversal that focuses on all the words of a string. Words are substrings that are separated by whitespace.</p> <p>When written through, words can be removed by writing the empty string, or changed to longer or shorter strings.</p> <pre><code>O.collect(O.words, 'foo, bar')\n// ['foo,', 'bar']\n\nO.modify(O.words, (word) =&gt; word.split('').reverse().join(''), 'foo, bar')\n// ',oof rab'\n</code></pre>"},{"location":"reference-standalone/#miscellaneous","title":"Miscellaneous","text":""},{"location":"reference-standalone/#eq","title":"<code>eq</code>","text":"<p><code>eq :: Equivalence</code></p> <p>Equivalence is a no-op that does nothing. Acts as an identity wrt. composition.</p>"},{"location":"reference-standalone/#pipe","title":"<code>pipe</code>","text":"<p><code>pipe :: (a, f1, f2, ...) =&gt; v</code></p> <p>Pipe the value of an expression (<code>a</code>) into a pipeline of at most 9 unary functions (<code>f1</code>, <code>f2</code>, ...).</p> <p>Example:</p> <pre><code>pipe(\n{ foo: 1, bar: { baz: 2 } },\nO.set(O.prop('foo'), 3),\nO.modify(O.compose('bar', 'baz'), (v: number) =&gt; -v)\n)\n// { foo: 3, bar: { baz: -2 } }\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":"<p>One of the following imports is assumed in all the examples.</p> <p>Method chaining:</p> <pre><code>import * as O from 'optics-ts'\n</code></pre> <p>Standalone:</p> <pre><code>import * as O from 'optics-ts/standalone'\n</code></pre> <p>See The Two Syntaxes for the difference between the two, and which one to choose. All the descriptions and examples below are given in terms of both syntaxes.</p>"},{"location":"tutorial/#lens","title":"Lens","text":"Method chaining <p>Lens is the most common optic you're going to use. You can create an optic for a data structure by calling <code>optic()</code>, and turn in into a lens that focuses on a property of an object with <code>prop</code>:</p> <pre><code>type Data = {\nfoo: { bar: number }\nother: string\n}\nconst foo = O.optic&lt;Data&gt;().prop('foo')\n</code></pre> <p><code>foo</code> is now a lens that focuses on <code>Data.foo</code>.</p> <p>To dig deeper, just call <code>prop</code> again:</p> <pre><code>const bar = O.optic&lt;Data&gt;().prop('foo').prop('bar')\n// or from the `foo` lens we defined above\nconst bar = foo.prop('bar')\n// or use .path() to compose multiple prop lenses with a single call\nconst bar = O.optic&lt;Data&gt;().path('foo', 'bar')\n// or use path with a dotted string path\nconst bar = O.optic&lt;Data&gt;().path('foo.bar')\n</code></pre> <p>Use <code>get</code> to read a value through the lens:</p> <pre><code>const data: Data = {\nfoo: { bar: 42 },\nother: 'stuff',\n}\n\nO.get(bar)(data)\n// 42\n</code></pre> <p>Use <code>set</code> or <code>modify</code> to write the focused value through the lens:</p> <pre><code>O.set(bar)(99)(data)\n// {\n//   foo: { bar: 99 },\n//   other: 'stuff'\n// }\n\nO.modify(bar, (x) =&gt; x * 100, data)\n// {\n//   foo: { bar: 4200 },\n//   other: 'stuff'\n// }\n</code></pre> Standalone <p>Lens is the most common optic you're going to use. You can create a lens that focuses on a property of an object with <code>prop</code>:</p> <pre><code>const foo = O.prop('foo')\n</code></pre> <p><code>foo</code> is now a lens that focuses on the prop <code>foo</code> of any given object.</p> <p>To dig deeper, compose multiple <code>prop</code> lenses:</p> <pre><code>const bar = O.compose(O.prop('foo'), O.prop('bar'))\n// or reusing the `foo` lens we defined above\nconst bar = O.compose(foo, O.prop('bar'))\n</code></pre> <p>Because <code>prop</code> is such an often used lens, you can pass string arguments directly to <code>compose</code>, and they will be taken as the <code>prop</code> lens:</p> <pre><code>const bar = O.compose('foo', 'bar')\n</code></pre> <p>Use <code>get</code> to read a value through the lens:</p> <pre><code>const data = {\nfoo: { bar: 42 },\nother: 'stuff',\n}\n\nO.get(bar, data)\n// 42\n</code></pre> <p>Use <code>set</code> or <code>modify</code> to write the focused value through the lens:</p> <pre><code>O.set(bar, 99, data)\n// {\n//   foo: { bar: 99 },\n//   other: 'stuff'\n// }\n\nO.modify(bar, (x) =&gt; x * 100, data)\n// {\n//   foo: { bar: 4200 },\n//   other: 'stuff'\n// }\n</code></pre> <p>Writing through optics always creates a new data structure instead of modifying the existing one in place, shallowly copying the required parts. In other words, data is immutable.</p>"},{"location":"tutorial/#prism","title":"Prism","text":"<p>Lenses are great for focusing to a part of a larger structure. Prisms are much like lenses, but they don't necessarily match anything, i.e. they can have zero focuses.</p> <p>A practical example is focusing on a branch of a union type. Here, the <code>User.age</code> field can be <code>number</code> or <code>undefined</code>. With the <code>optional</code> prism we can focus only when the value is a <code>number</code>, and do nothing when it's <code>undefined</code>:</p> Method chaining <pre><code>type User = {\nname: string\nage?: number | undefined\n}\n\nconst age = O.optic&lt;User&gt;().prop('age').optional()\n</code></pre> Standalone <pre><code>type User = {\nname: string\nage?: number | undefined\n}\n\nconst age = O.compose('age', O.optional)\n</code></pre> <p>You read through a prism using the <code>preview</code> function. When the prism doesn't match, it returns <code>undefined</code>.</p> Method chaining <pre><code>const userWithAge: User = {\nname: 'Betty',\nage: 42,\n}\nO.preview(age)(userWithAge)\n// 42\n\nconst userWithoutAge: User = {\nname: 'Max',\nage: undefined,\n}\nO.preview(age)(userWithoutAge)\n// undefined\n</code></pre> Standalone <pre><code>const userWithAge: User = {\nname: 'Betty',\nage: 42,\n}\nO.preview(age, userWithAge)\n// 42\n\nconst userWithoutAge: User = {\nname: 'Max',\nage: undefined,\n}\nO.preview(age, userWithoutAge)\n// undefined\n</code></pre> <p>You can write through a prism normally with <code>set</code> and <code>modify</code>. If the prism doesn't match, the value is unchanged:</p> Method chaining <pre><code>O.modify(age)((n) =&gt; n + 1)(userWithAge)\n// {\n//   name: 'Betty',\n//   age: 43,\n// }\n\nO.set(age)(60)(userWithoutAge)\n// {\n//   name: 'Max',\n//   age: undefined,\n// }\n</code></pre> Standalone <pre><code>O.modify(age, (n) =&gt; n + 1, userWithAge)\n// {\n//   name: 'Betty',\n//   age: 43,\n// }\n\nO.set(age, 60, userWithoutAge)\n// {\n//   name: 'Max',\n//   age: undefined,\n// }\n</code></pre> <p><code>guard</code> is another way to create a prism. It's a generalization of <code>optional</code> in the sense that you can match on any branch of a union type instead of just the non-<code>undefined</code> part:</p> <pre><code>interface Circle {\nkind: 'circle'\nradius: number\n}\ninterface Rectangle {\nkind: 'rectangle'\nwidth: number\nheight: number\n}\ntype Shape = Circle | Rectangle\n\nfunction isRectangle(s: Shape): s is Rectangle {\nreturn s.kind === 'rectangle'\n}\n</code></pre> Method chaining <pre><code>const rectWidth = O.optic&lt;Shape&gt;().guard(isRectangle).prop('width')\n\nO.preview(rectWidth)({ kind: 'circle', radius: 10 })\n// undefined\n\nO.preview(rectWidth)({ kind: 'rectangle', width: 5, height: 7 })\n// 5\n\nO.modify(rectWidth)((w) =&gt; w * 2)({ kind: 'rectangle', width: 5, height: 7 })\n// { kind: 'rectangle', width: 10, height: 7 })\n</code></pre> Standalone <pre><code>const rectWidth = O.compose(O.guard(isRectangle), 'width')\n\nO.preview(rectWidth, { kind: 'circle', radius: 10 })\n// undefined\n\nO.preview(rectWidth, { kind: 'rectangle', width: 5, height: 7 })\n// 5\n\nO.modify(rectWidth, (w) =&gt; w * 2, { kind: 'rectangle', width: 5, height: 7 })\n// { kind: 'rectangle', width: 10, height: 7 })\n</code></pre> <p>Notice how above we composed the <code>guard</code> prism with the <code>prop</code> lens. This yields a prism, so we used <code>preview</code> to read through it. See Rules of composition for more info.</p>"},{"location":"tutorial/#removable-optics","title":"Removable optics","text":"<p>Some optics are removable. This means that they focus on an element of a container (e.g. an array), and you can remove the element from the container.</p> <p><code>at</code> is a removable prism. It focuses on an index of an array, and lets you also remove that index:</p> Method chaining <pre><code>interface User {\nname: string\n}\n\nconst threeUsers: User[] = [\n{ name: 'Max' },\n{ name: 'Betty' },\n{ name: 'Alice' },\n]\n\nconst secondUser = O.optic&lt;User[]&gt;().at(1)\nO.remove(secondUser)(threeUsers)\n// [{ name: 'Max' }, { name: 'Alice' }]\n</code></pre> Standalone <pre><code>interface User {\nname: string\n}\n\nconst threeUsers: User[] = [\n{ name: 'Max' },\n{ name: 'Betty' },\n{ name: 'Alice' },\n]\n\nO.remove(O.at(1), threeUsers)\n// [{ name: 'Max' }, { name: 'Alice' }]\n</code></pre> <p>If the optic doesn't match, removing has no effect:</p> Method chaining <pre><code>const oneUser: User[] = [{ name: 'Max' }]\n\nO.remove(secondUser)(oneUser)\n// [{ name: 'Max' }]\n</code></pre> Standalone <pre><code>const oneUser: User[] = [{ name: 'Max' }]\n\nO.remove(O.at(1), oneUser)\n// [{ name: 'Max' }]\n</code></pre>"},{"location":"tutorial/#traversal","title":"Traversal","text":"<p>The next optic type is the traversal. While lenses have one focus and prisms have zero or one focuses (no match or match), traversals have zero or more focuses.</p> <p>The simplest example of a traversal is to focus on all elements of an array. To create such a traversal, use <code>elems</code>:</p> Method chaining <pre><code>type Person {\nname: string\nfriends: Person[]\n}\n\nconst friendsNames = O.optic&lt;Person&gt;()\n.prop('friends')\n.elems()\n.prop('name')\n</code></pre> Standalone <pre><code>type Person {\nname: string\nfriends: Person[]\n}\n\nconst friendsNames = O.compose('friends', O.elems, 'name')\n</code></pre> <p>To read through a traversal, call <code>collect</code> to collect all focused elements into an array:</p> Method chaining <pre><code>const john = { name: 'John', friends: [] }\nconst bruce = { name: 'Bruce', friends: [] }\nconst amy = { name: 'Amy', friends: [john, bruce] }\n\nO.collect(friendsNames)(amy)\n// [ 'John', 'Bruce' ]\n</code></pre> Standalone <pre><code>const john = { name: 'John', friends: [] }\nconst bruce = { name: 'Bruce', friends: [] }\nconst amy = { name: 'Amy', friends: [john, bruce] }\n\nO.collect(friendsNames, amy)\n// [ 'John', 'Bruce' ]\n</code></pre> <p>Writing through a traversal writes to all focused values:</p> Method chaining <pre><code>O.modify(friendsNames)((name) =&gt; `${name} Wayne`)(amy)\n// {\n//   name: 'Amy',\n//   friends: [\n//     { name: 'John Wayne', friends: [] },\n//     { name: 'Bruce Wayne', friends: [] },\n//   ],\n// }\n</code></pre> Standalone <pre><code>O.modify(friendsNames, (name) =&gt; `${name} Wayne`, amy)\n// {\n//   name: 'Amy',\n//   friends: [\n//     { name: 'John Wayne', friends: [] },\n//     { name: 'Bruce Wayne', friends: [] },\n//   ],\n// }\n</code></pre> <p>Note again how we used <code>prop</code>, <code>elems</code> and <code>prop</code>, composing a lens with a traversal, and then with a lens again. This yields a traversal. See Rules of composition for more info.</p> <p>It's sometimes useful to further focus on certain elements of a traversal. This can be done by composing a traversal with a prism like <code>when</code> that skips items that don't match a predicate:</p> Method chaining <pre><code>const even = O.optic&lt;number[]&gt;()\n.elems()\n.when((n) =&gt; n % 2 === 0)\n\nO.modify(even)((n) =&gt; -n)([1, 2, 3, 4, 5])\n// [1, -2, 3, -4, 5]\n</code></pre> Standalone <pre><code>const even = O.compose(\nO.elems,\nO.when((n: number) =&gt; n % 2 === 0)\n)\n\nO.modify(even, (n) =&gt; -n, [1, 2, 3, 4, 5])\n// [1, -2, 3, -4, 5]\n</code></pre>"},{"location":"tutorial/#polymorphism","title":"Polymorphism","text":"Method chaining <p>Optics can be polymorphic, which means you can change the type of the focus when you write through an optic. Since this is a relatively rare use case, and may be confusing if done by accident, polymorphic optics are created with <code>optic_</code> (note the underscore):</p> <pre><code>type Data = {\nfoo: { bar: string }\nother: boolean\n}\nconst bar = O.optic_&lt;Data&gt;().path('foo.bar')\n</code></pre> Standalone <p>Optics can be polymorphic, which means you can change the type of the focus when you write through an optic.</p> <pre><code>type Data = {\nfoo: { bar: string }\nother: boolean\n}\nconst bar = O.compose('foo', 'bar')\n</code></pre> <p>Let's modify <code>bar</code> to contain the length of the original string instead:</p> Method chaining <pre><code>const data: Data = {\nfoo: { bar: 'hello there' },\nother: true,\n}\n\nconst updated = O.modify(bar)((str) =&gt; str.length)(data)\n// {\n//   foo: { bar: 11 },\n//   other: true\n// }\n</code></pre> <p>This is a type-safe operation, i.e. the compiler knows that the type of <code>updated.foo.bar</code> is <code>number</code>, editor autocomplete works correctly, etc.</p> <p>If you ever see a <code>DisallowedTypeChange</code> type being returned from an <code>optics-ts</code> function, it means that you tried to change the type when writing through a non-polymorphic (monomorphic) optic.</p> Standalone <pre><code>const data: Data = {\nfoo: { bar: 'hello there' },\nother: true,\n}\n\nconst updated = O.modify(bar, (str) =&gt; str.length, data)\n// {\n//   foo: { bar: 11 },\n//   other: true\n// }\n</code></pre> <p>This is a type-safe operation, i.e. the compiler knows that the type of <code>updated.foo.bar</code> is <code>number</code>, editor autocomplete works correctly, etc.</p>"},{"location":"two-syntaxes/","title":"The Two Syntaxes","text":"<p>Since optics-ts v2.2.0, there are two syntaxes for optics: method chaining and standalone optics. Method chaining is the default, tried and tested syntax. Standalone syntax is still experimental, but it's likely to become the default in the future.</p> <p>In the other parts of the documentation, all examples are given in terms of both syntaxes. There are also slight semantic differences in certain optics, which are clearly documented.</p> <p>The following sections summarize the biggest differences between the syntaxes.</p>"},{"location":"two-syntaxes/#importing","title":"Importing","text":"<p>Method chaining</p> <pre><code>import * as O from 'optics-ts'\n</code></pre> <p>Standalone</p> <pre><code>import * as O from 'optics-ts/standalone'\n</code></pre>"},{"location":"two-syntaxes/#composing","title":"Composing","text":"<p>Method chaining</p> <p>The name of this syntax is \"method chaining\", because optics are composed by method chaining, also known as a fluent interface. Composition always starts with some root type (<code>MyType</code> in the example below), which ties the optic to the type of the data structure it manipulates.</p> <pre><code>O.optic&lt;MyType&gt;()\n.prop('foo')\n.optional()\n.when((value) =&gt; value &gt; 42)\n</code></pre> <p>Standalone</p> <p>The name of this syntax comes from the fact that optics are standalone functions and values, i.e. they \"float\" without being tied to any concrete type. They of course require the data to be of a specific shape, but you don't need to explicitly state the type in your code.</p> <p>The implication of not tying the optics to any particular type beforehand means that you need to add type annotations to some places, like <code>(value: number) =&gt; ...</code> for <code>O.when</code>'s parameter in the example below.</p> <pre><code>O.compose(\n'foo',\nO.optional,\nO.when((value: number) =&gt; value &gt; 42)\n)\n</code></pre>"},{"location":"two-syntaxes/#currying","title":"Currying","text":"<p>Method chaining</p> <p>Operation functions like <code>O.get</code>, <code>O.modify</code> and <code>O.set</code> are available in the fully curried form only:</p> <pre><code>O.get(myOptic)(myData)\nO.modify(myOptic)((value) =&gt; value + 1)(myData)\n</code></pre> <p>Standalone</p> <p>Both curried and uncurried versions are available:</p> <pre><code>O.get(myOptic, myData)\nO.get(myOptic)(myData)\n\nO.modify(myOptic, (value) =&gt; value + 1, myData)\nO.modify(myOptic)((value) =&gt; value + 1, myData)\nO.modify(myOptic)((value) =&gt; value + 1)(myData)\n</code></pre>"},{"location":"two-syntaxes/#tree-shaking","title":"Tree shaking","text":"<p>Method chaining</p> <p>Tree shaking is not possible. The whole library is always included in the bundle.</p> <p>Standalone</p> <p>Fully tree shakeable. Only the features you use are included in the bundle.</p>"},{"location":"two-syntaxes/#compilation-speed","title":"Compilation speed","text":"<p>It seems that compiling large programs using the standalone syntax is somewhat slower compared to method chaining. However, a good, repeatable benchmark is still on the TODO list. Also, future improvements in the TypeScript compiler may affect compilation speeds dramatically.</p>"},{"location":"two-syntaxes/#runtime-performance","title":"Runtime performance","text":"<p>There should be no performance difference between the two, although there's no benchmark demonstrating this either, yet.</p>"}]}